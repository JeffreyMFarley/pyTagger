from configargparse import getArgumentParser
from collections import namedtuple
from pyTagger.utils import defaultConfigFiles


def makeEnum(name, *sequential, **named):
    """Implement an enum type in python

    Credit: https://stackoverflow.com/questions/36932/
    """
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type(name, (), enums)


COMPARISON = makeEnum(
    'Comparison', 'EQUAL', 'NOT', 'GT', 'GTE', 'LT', 'LTE', 'LIKE'
)
"""Enumerated values used with :func:`pyTagger.actions.where.process`"""


class FilterCondition(namedtuple('FilterCondition_', [
    'field', 'comparison', 'value'
])):
    """A named tuple class that tracks WHERE conditions

    Members:
            field (str): The field to compare

            comparison (:data:`COMPARISON`): The type of comparision

            value: The value to compare

    """
    pass


class TrackMatch(namedtuple('TrackMatch_', [
    'status', 'newPath', 'oldPath', 'score', 'newTags', 'oldTags'
])):
    """Instances of this class are generated by
    :func:`pyTagger.operations.find_duplicates.findIsonoms` and identify a
    possible match between two tracks.

    Members:
        status (str):   Tracks the status of the match.
            'single':   There is only one match for `newTags` in the set

            'multiple': There are multiple matches for `newTags` in the set

            'nothing':  There are no matches for `newTags`

            'insufficient': An error occurred during matching

            'ready':    The match has been validated

            'manual':   The match will require manual editing

        newPath (str):  The file location of the track being matched

        oldPath (str):  The file location of a potential match

        score (float):  The strength of the match.  Higher is better

        newTags (dict): The tags of the track being matched

        oldTags (dict): The tags of the potential match
    """
    pass


#------ Snapshot --------------------------------------------------------------

class Snapshot(object):
    """The main data structure of the application.
    It is a dictionary of paths with each path holding a dictionary of ID3 tags

    **Example**

    .. code-block:: javascript

       {
         '/path/to/file1': {'artist': 'foo', 'album': 'bar'},
         '/path/to/file2': {'artist': 'foo', 'album': 'baz'}
       }

    """
    basic = ['title', 'track', 'totalTrack', 'artist',
             'albumArtist', 'album', 'length']
    """Tags for the most widely supported information about a track"""

    songwriting = ['bpm', 'composer', 'key', 'lyrics', 'language']
    """Tags related to the composition and musical form of the track"""

    production = ['year', 'releaseDate', 'originalReleaseDate',
                  'recordingDate', 'conductor', 'remixer', 'publisher']
    """Tags related to the publication and release of the track"""

    distribution = ['barcode', 'media', 'disc', 'totalDisc']
    """Tags related to how this track was packaged"""

    library = ['genre', 'id', 'ufid', 'compilation', 'comments', 'playCount',
               'group', 'subtitle', 'encodingDate', 'taggingDate']
    """Tags useful to those who obsessively curate their music collection ;)"""

    mp3Info = ['bitRate', 'vbr', 'fileHash', 'version']
    """Tags related to how this track is encoded"""

    dltTags = ['comments', 'lyrics']
    """Tags that have the form: 'Description', 'Language' and 'Text'"""

    complexTags = ['comments', 'lyrics', 'ufid']
    """Tags that can have multiple instances in the same track"""

    integerTags = [
        'track', 'totalTrack', 'length',
        'disc', 'totalDisc',
        'compilation', 'playCount',
        'bitRate'
    ]
    """Numeric tags"""

    @staticmethod
    def orderedAllColumns():
        """Provides an ordered list of all supported ID3 tags"""
        # preserve order
        columns = (Snapshot.basic +
                   Snapshot.songwriting +
                   Snapshot.production +
                   Snapshot.distribution +
                   Snapshot.library +
                   Snapshot.mp3Info)

        return columns

    @staticmethod
    def columnsFromSnapshot(data):
        """Determines the tags used in a snapshot

        Args:
            data (:data:`Snapshot`): The snapshot to analyze

        Returns:
            A list of tags from the snapshot in the following order:

            1. The standard order
            2. Any unrecognized fields in alphanumeric order
        """
        header = set()

        for v in data.values():
            for j in v.keys():
                if j not in header:
                    header.add(j)

        # Build the ordered set with the extra columns at the end
        known = Snapshot.orderedAllColumns()
        unknown = header - set(known)

        columns = [c for c in known if c in header]
        for c in sorted(unknown):
            columns.append(c)

        return columns

    @staticmethod
    def columnsFromArgs(args):
        """Determines which tags are requested from command line options

        Args:
            args (argparse): The options parsed from the command line or
            configuration file

        Returns:
            An ordered list of all requested tags

        If args does not contain any tag options, the :data:`basic` set will be
        returned.
        """
        columns = []
        if args.basic:
            columns = columns + Snapshot.basic
        if args.songwriting:
            columns = columns + Snapshot.songwriting
        if args.production:
            columns = columns + Snapshot.production
        if args.distribution:
            columns = columns + Snapshot.distribution
        if args.library:
            columns = columns + Snapshot.library
        if args.mp3Info:
            columns = columns + Snapshot.mp3Info
        if args.all:
            columns = Snapshot.orderedAllColumns()

        if not columns:
            columns = Snapshot.basic

        return columns


p = getArgumentParser('snapshot',
                      default_config_files=defaultConfigFiles,
                      parents=[getArgumentParser()],
                      description='control which columns are included in the'
                      'snapshot')
group = p.add_argument_group('Columns')
group.add_argument('--basic', action='store_true', dest='basic',
                   help=' '.join(Snapshot.basic))
group.add_argument('--songwriting', action='store_true',
                   dest='songwriting', help=' '.join(Snapshot.songwriting))
group.add_argument('--production', action='store_true',
                   dest='production', help=' '.join(Snapshot.production))
group.add_argument('--distribution', action='store_true',
                   dest='distribution', help=' '.join(Snapshot.distribution))
group.add_argument('--library', action='store_true', dest='library',
                   help=' '.join(Snapshot.library))
group.add_argument('--mp3Info', action='store_true', dest='mp3Info',
                   help=' '.join(Snapshot.mp3Info))
group.add_argument('--all', action='store_true', dest='all',
                   help='include all supported fields')
